# Contribute a New Matcher

!!! note
    This part was generated by LLM.

The core responsibility of a Matcher is to determine if a connection meets a specific criterion based on its characteristics.

## Contribution Steps

### 1. Create the Matcher File

In the `matcher/` directory, create a new Go file. The filename should reflect the function of your matcher, for example, `my_matcher.go`.

### 2. Define the Configuration Struct

  - Define a configuration struct for your matcher. This struct must use `yaml` tags so that parameters can be parsed from the configuration file.
  - For example, if you wanted to create a matcher based on the client's port number:
    ```go
    type PortMatcherConfig struct {
    	Port int `yaml:"port"`
    }
    ```

### 3. Implement the Matcher Interface

  - Your Matcher struct must implement the `matcher.Matcher` interface, which has a single method:
    ```go
    type Matcher interface {
    	Match(conn net.Conn, data []byte) bool
    }
    ```
  - Implement your matching logic in the `Match` method. You can use the `conn` parameter to get connection metadata (like the IP address) or the `data` parameter to inspect the pre-read traffic content.
      - **Important**: `data` only contains the first few bytes (up to 8KB) that TCPMux has sniffed. If your matching logic requires more data, you might need to use a `prefixedConn`, but this is usually the responsibility of a `handler`, not a `matcher`.
  - Here's a simple implementation example:
    ```go
    type PortMatcher struct {
    	config *PortMatcherConfig
    }

    func (m *PortMatcher) Match(conn net.Conn, data []byte) bool {
    	_, portStr, err := net.SplitHostPort(conn.RemoteAddr().String())
    	if err != nil {
    		return false
    	}
    	port, err := strconv.Atoi(portStr)
    	if err != nil {
    		return false
    	}
    	return port == m.config.Port
    }
    ```

### 4. Create the Factory Function

  - Write a **factory function** that is responsible for creating an instance of your Matcher from a YAML node.
  - The function must adhere to the `matcher.MatcherFactory` signature: `func(yaml.Node) (Matcher, error)`.
  - Inside the factory function, use the `Decode` method on `yaml.Node` to parse the configuration.
    ```go
    func newPortMatcher(parameter yaml.Node) (Matcher, error) {
    	cfg := &PortMatcherConfig{}
    	if err := parameter.Decode(cfg); err != nil {
    		return nil, fmt.Errorf("failed to decode port matcher config: %v", err)
    	}
    	return &PortMatcher{config: cfg}, nil
    }
    ```

### 5. Register Your Matcher

  - In the `init()` function of your file, use the `matcher.Register` function to register your matcher. This is the crucial step for TCPMux to dynamically load your matcher.
  - The registration name (the first parameter) will be the `type` value that users will use in their configuration file.
    ```go
    func init() {
    	Register("port", newPortMatcher)
    }
    ```

### 6. Add Documentation

  - Add clear YAML configuration examples for your new matcher so other contributors and users understand how to use it.

