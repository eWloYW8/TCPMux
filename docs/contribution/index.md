# Architecture

!!! note
    This part was generated by LLM.

## Core Workflow

The TCPMux workflow can be summarized in a simple loop:

1.  **Listen**: TCPMux starts and listens on the TCP addresses specified in the configuration.
2.  **Accept Connection**: When a new connection arrives, it accepts it.
3.  **Traffic Sniffing**: Before passing the connection to any handler, TCPMux reads the first few bytes of the connection (up to 8KB) to "sniff" the traffic type (e.g., TLS, HTTP, SSH).
4.  **Rule Matching**: TCPMux iterates through the **rule list** in the configuration. Each rule contains a **Matcher**. It uses the sniffed data and connection metadata (like the client's IP) to determine if the current connection matches the rule.
5.  **Handle Connection**: Once the first matching rule is found, TCPMux passes the connection to the **Handler** specified by that rule. The handler takes over the connection and is responsible for processing all subsequent traffic according to its logic.
6.  **No Match**: If no rule is successfully matched, TCPMux closes the connection by default.

## Core Component Breakdown

TCPMux's extensibility primarily comes from its core **Matcher** and **Handler** modules.

### Matcher

The Matcher is responsible for **identifying** the incoming connection.

  - It implements the `matcher.Matcher` interface, which has a single method: `Match(conn net.Conn, data []byte) bool`.
  - `data` contains the pre-read bytes sniffed by TCPMux, which is the key information for matching.
  - You can create custom matchers based on protocol (`http`, `ssh`), connection metadata (`ip`, TLS SNI), or data content (`regex`, `substring`).
  - Logical combination matchers (`and`, `or`) allow you to build complex matching logic.

### Handler

The Handler is responsible for **processing** a successfully matched connection.

  - It implements the `handler.Handler` interface, also with a single method: `Handle(conn net.Conn)`.
  - The handler takes complete control of the connection and is responsible for its entire lifecycle.

### Registry Pattern

TCPMux uses a **registry pattern** to dynamically load matchers and handlers.

  - Each matcher or handler is registered via an `init()` function within its respective package.
  - The `matcher.Register` and `handler.Register` functions associate the type name of a matcher/handler with its factory function.
  - In `server.go`, the `NewServer` function dynamically creates instances based on the `type` field in the configuration file, using the registered factory functions.
