{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"TCPMux","text":"<p>TCPMux is a TCP traffic multiplexer written in Go, which enables you to host multiple application-layer protocols on a single port.</p>"},{"location":"#usage","title":"Usage","text":"<p>Start the server with a configuration file:</p> <pre><code>./TCPMux --config config.yaml\n</code></pre> <p>For more details on configuration, see the Configuration section.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Follow our Quick Start guide to get your first TCPMux instance.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>TCPMux uses a single YAML configuration file to define its behavior. The file specifies network listeners, logging settings, and a set of rules for routing traffic.</p>"},{"location":"configuration/#file-structure","title":"File Structure","text":"<p>A typical <code>config.yaml</code> file looks like this:</p> <pre><code>listen:\n  - \"0.0.0.0:443\"\n\nlogging:\n  level: \"info\"\n  stderr: true\n\ntls:\n  enabled: true\n  config:\n    - sni: \"myservice.com\"\n      cert: \"path/to/myservice.com.crt\"\n      key: \"path/to/myservice.com.key\"\n\nrules:\n  - name: \"my-tls-rule\"\n    type: \"tls\"\n    tls_required: true\n    parameter:\n      sni: \"myservice.com\"\n    handler:\n      name: \"my-handler\"\n      type: \"passthrough\"\n      parameter:\n        backend: \"127.0.0.1:8443\"\n        tls:\n          enabled: true\n          insecure_skip_verify: true\n\ncontroller:\n  enabled: true\n  listen: \"127.0.0.1:12067\"\n</code></pre>"},{"location":"configuration/#using-yaml-anchors","title":"Using YAML Anchors","text":"<p>For complex configurations with many rules, it's highly recommended to use YAML anchors (<code>&amp;</code>) and aliases (<code>*</code>) to define handlers once and reuse them across multiple rules. This prevents repetition and makes your configuration file much cleaner and easier to manage.</p> <p>Anchor (<code>&amp;</code>): Defines a reusable block. Alias (<code>*</code>): Refers to a defined anchor.</p>"},{"location":"configuration/#example-with-anchors","title":"Example with Anchors","text":"<pre><code>tls:\n  enabled: true\n  config:\n    - sni: \"*.example.com\"\n      cert: /path/to/cert.pem\n      key: /path/to/key.pem\n    - sni: \"*\"\n      cert: /path/to/default_cert.pem\n      key: /path/to/default_key.pem\n\nhandler:\n  - &amp;ssh_handler\n    name: \"SSH Handler\"\n    type: \"passthrough\"\n    parameter:\n      backend: \"127.0.0.1:22\"\n      tls: \n        enabled: false\n  - &amp;http_handler\n    name: \"HTTP Handler\"\n    type: \"passthrough\"\n    parameter:\n      backend: \"127.0.0.1:80\"\n      tls: \n        enabled: false\n\nrules:\n  - name: \"SSH Rule\"\n    type: \"substring\"\n    parameter:\n      offset: 0\n      value: \"SSH-\"\n    handler: *ssh_handler\n\n  - name: \"HTTP Rule\"\n    type: \"regex\"\n    parameter:\n      pattern: \"^(GET|POST|HEAD|PUT|DELETE|OPTIONS|TRACE|CONNECT)\\\\s+\\\\/?.*?\\\\s+HTTP\\\\/[0-9.]+\"\n    handler: *http_handler\n\n  - name: \"default Rule\"\n    type: \"default\"\n    handler: *ssh_handler\n\n  - name: \"timeout Rule\"\n    type: \"timeout\"\n    parameter:\n      timeout: 5\n    handler: *ssh_handler\n\nlogging:\n  level: \"debug\"\n  stderr: true\n  file: \"TCPMux.log\"\n  format: \"console\"\n\nlisten:\n  - \"[::]:10443\"\n  - \"[::]:24067\"\n</code></pre>"},{"location":"configuration/controller/","title":"Controller","text":"<p>The <code>controller</code> module provides a set of HTTP and WebSocket endpoints for monitoring and managing the TCPMux server in real time.</p>"},{"location":"configuration/controller/#fields","title":"Fields","text":"<ul> <li><code>enabled</code> (<code>bool</code>, optional): If <code>true</code>, the controller module will be activated. The server will listen on the specified address for API and WebSocket connections. Defaults to <code>false</code>.</li> <li><code>listen</code> (<code>string</code>, optional): The address and port for the controller to listen on (e.g., <code>localhost:9000</code>). This field is required if <code>enabled</code> is <code>true</code>.</li> </ul>"},{"location":"configuration/controller/#endpoints","title":"Endpoints","text":""},{"location":"configuration/controller/#rest-api","title":"REST API","text":"<ul> <li> <p><code>GET /connections</code></p> <ul> <li>Description: Retrieves a list of all currently active TCP connections being handled by the server.</li> <li>Response: A JSON array of objects, where each object represents a connection with details like ID, remote address, bytes transferred, and matched rule name.</li> </ul> </li> <li> <p><code>POST /connections/:id/close</code></p> <ul> <li>Description: Closes a specific active connection. The <code>:id</code> parameter should be replaced with the unique connection ID obtained from the <code>/connections</code> endpoint.</li> <li>Response: A JSON object confirming the closure or an error message if the connection is not found.</li> </ul> </li> <li> <p><code>GET /logs</code></p> <ul> <li>Description: Returns the full content of the log file configured in the <code>logging</code> section. The content type is <code>text/plain</code>.</li> <li>Response: The raw text content of the log file.</li> </ul> </li> </ul>"},{"location":"configuration/controller/#websocket","title":"WebSocket","text":"<ul> <li> <p><code>GET /ws/connections</code></p> <ul> <li>Description: Establishes a WebSocket connection to receive a real-time stream of active connections. The server broadcasts a complete list of connections every second.</li> <li>Protocol: WebSocket</li> <li>Data Format: A JSON array of connection objects, identical to the <code>/connections</code> endpoint response, streamed at a fixed interval.</li> </ul> </li> <li> <p><code>GET /ws/logs</code></p> <ul> <li>Description: Establishes a WebSocket connection to stream new log entries as they are written to the log file.</li> <li>Protocol: WebSocket</li> <li>Data Format: A stream of individual log entries, each as a new line of text, following the format (<code>console</code> or <code>json</code>) specified in the logging configuration.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>controller:\n  enabled: true\n  listen: \"localhost:9000\"\n</code></pre>"},{"location":"configuration/listen/","title":"Listen","text":"<p>The <code>listen</code> field is a list of network addresses on which TCPMux will listen for incoming connections.</p> <p>Type: <code>[]string</code></p> <p>Example:</p> <pre><code>listen:\n  - \"0.0.0.0:80\"\n  - \"0.0.0.0:443\"\n</code></pre>"},{"location":"configuration/logging/","title":"Logging","text":"<p>The <code>logging</code> section of the configuration file controls where and how log output is generated.</p>"},{"location":"configuration/logging/#fields","title":"Fields","text":"<ul> <li><code>level</code> (<code>string</code>, required): The minimum log level to display. Options are <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, and <code>fatal</code>.</li> <li><code>stderr</code> (<code>bool</code>, optional): If <code>true</code>, logs will be written to standard error. Defaults to <code>true</code>.</li> <li><code>file</code> (<code>string</code>, optional): The path to a file where logs will be written.</li> <li><code>format</code> (<code>string</code>, optional): The log format. Options are <code>console</code> (default) or <code>json</code>.</li> </ul> <p>Example:</p> <pre><code>logging:\n  level: \"debug\"\n  stderr: true\n  file: \"/var/log/tcpmux.log\"\n  format: \"json\"\n</code></pre>"},{"location":"configuration/rules/","title":"Rules","text":"<p>TCPMux's core functionality is defined by <code>rules</code>, which are processed in the order they appear in the configuration file.</p>"},{"location":"configuration/rules/#rule-fields","title":"Rule Fields","text":"<p>Each rule is an object with the following fields:</p> <ul> <li><code>name</code> (<code>string</code>, required): A unique name for the rule.</li> <li><code>type</code> (<code>string</code>, required): The type of matcher to use. See the Matchers section for available types.</li> <li><code>tls_required</code> (<code>bool</code>, optional): If <code>true</code>, the rule will only be considered for connections that have completed a TLS handshake.</li> <li><code>parameter</code> (<code>yaml.Node</code>, required): Parameters specific to the chosen <code>type</code>.</li> <li><code>handler</code> (<code>HandlerConfig</code>, required): The handler to execute if the rule matches. See the Handlers section for available types.</li> </ul>"},{"location":"configuration/rules/#rule-matching-process","title":"Rule Matching Process","text":"<p>When a new connection is received, TCPMux iterates through the <code>rules</code> list. The first rule whose matcher returns <code>true</code> for the connection's initial data (or TLS handshake information) will be used to execute its corresponding handler.</p>"},{"location":"configuration/tls/","title":"TLS","text":"<p>The <code>tls</code> section allows you to configure TLS for incoming connections.</p>"},{"location":"configuration/tls/#fields","title":"Fields","text":"<ul> <li><code>enabled</code> (<code>bool</code>, required): If <code>true</code>, TCPMux will attempt to perform a TLS handshake on connections that appear to be TLS.</li> <li><code>config</code> (<code>[]SNIConfig</code>, required): A list of TLS configurations for different Server Name Indication (SNI) values.</li> </ul>"},{"location":"configuration/tls/#sniconfig","title":"<code>SNIConfig</code>","text":"<ul> <li><code>sni</code> (<code>string</code>, required): The Server Name Indication hostname. Use <code>*</code> to specify a default certificate for any SNI that doesn't have a specific match.</li> <li><code>cert</code> (<code>string</code>, required): Path to the certificate file.</li> <li><code>key</code> (<code>string</code>, required): Path to the private key file.</li> </ul> <p>Example:</p> <pre><code>tls:\n  enabled: true\n  config:\n    - sni: \"myservice.com\"\n      cert: \"/etc/ssl/myservice.com.crt\"\n      key: \"/etc/ssl/myservice.com.key\"\n    - sni: \"anotherservice.net\"\n      cert: \"/etc/ssl/anotherservice.net.crt\"\n      key: \"/etc/ssl/anotherservice.net.key\"\n    - sni: \"*\"\n      cert: \"/etc/ssl/default.crt\"\n      key: \"/etc/ssl/default.key\"\n</code></pre>"},{"location":"contribution/","title":"Architecture","text":"<p>WIP</p>"},{"location":"contribution/handler/","title":"Contribute a New Handler","text":"<p>WIP</p>"},{"location":"contribution/matcher/","title":"Contribute a New Matcher","text":"<p>WIP</p>"},{"location":"getting_started/installation/","title":"Installation","text":""},{"location":"getting_started/installation/#from-source","title":"From Source","text":"<p>Make sure you have Go installed (version 1.18 or later).</p> <ol> <li> <p>Clone the repository:     <pre><code>git clone https://github.com/eWloYW8/TCPMux\ncd TCPMux\n</code></pre></p> </li> <li> <p>Build the executable:</p> <pre><code>go mod tidy\ngo build\n</code></pre> </li> </ol> <p>This will create an executable named <code>TCPMux</code> (or <code>TCPMux.exe</code> on Windows) in your current directory.</p>"},{"location":"getting_started/installation/#pre-built-binaries","title":"Pre-built Binaries","text":"<p>Download pre-built binaries from the GitHub Releases page.</p>"},{"location":"getting_started/quickstart/","title":"Quick Start","text":""},{"location":"getting_started/quickstart/#1-create-a-configuration-file","title":"1. Create a Configuration File","text":"<p>Create a file named <code>config.yaml</code> with the following content:</p> <pre><code>listen:\n  - \"0.0.0.0:8080\"\nlogging:\n  level: \"info\"\nrules:\n  - name: \"http-rule\"\n    type: \"substring\"\n    parameter:\n      offset: 0\n      value: \"GET\"\n    handler:\n      name: \"http-handler\"\n      type: \"passthrough\"\n      parameter:\n        backend: \"127.0.0.1:8000\"\n</code></pre>"},{"location":"getting_started/quickstart/#2-start-a-backend-service","title":"2. Start a Backend Service","text":"<p>For this example, you need a simple web server running on <code>127.0.0.1:8000</code>. You can use Python for this:</p> <pre><code>python3 -m http.server 8000\n</code></pre>"},{"location":"getting_started/quickstart/#3-run-tcpmux","title":"3. Run TCPMux","text":"<p>Run the TCPMux server from your terminal:</p> <pre><code>./TCPMux --config config.yaml\n</code></pre> <p>TCPMux will now listen on port <code>8080</code>.</p>"},{"location":"getting_started/quickstart/#4-test-it","title":"4. Test It","text":"<p>Open your browser or use <code>curl</code> to send a request to <code>localhost:8080</code>. The request should be successfully forwarded to your Python web server.</p> <pre><code>curl http://localhost:8080\n</code></pre>"},{"location":"handlers/","title":"Handlers","text":"<p>Handlers are responsible for processing a connection once a rule has been matched.</p> <p>The <code>handler</code> field in a rule definition specifies which handler to use.</p> <p>The following handlers are available:</p> <ul> <li>Passthrough</li> <li>Reverse Proxy</li> <li>WebServer</li> <li>SOCKS5 Server</li> <li>Trojan Server</li> </ul>"},{"location":"handlers/passthrough/","title":"Passthrough Handler","text":"<p>The <code>passthrough</code> handler simply forwards all traffic from the client to a specified backend service and vice versa. It is the most common handler for proxying traffic.</p>"},{"location":"handlers/passthrough/#configuration","title":"Configuration","text":"<ul> <li><code>backend</code> (<code>string</code>, required): The address of the backend service (e.g., <code>127.0.0.1:8000</code>).</li> <li><code>tls</code> (<code>BackendTLSConfig</code>, optional): Configuration for TLS to the backend.</li> </ul>"},{"location":"handlers/passthrough/#backendtlsconfig","title":"<code>BackendTLSConfig</code>","text":"<ul> <li><code>enabled</code> (<code>bool</code>, optional): If <code>true</code>, TCPMux will initiate a TLS connection to the backend. Defaults to <code>false</code>.</li> <li><code>insecure_skip_verify</code> (<code>bool</code>, optional): If <code>true</code>, the TLS connection to the backend will not verify the backend's certificate.</li> <li><code>sni</code> (<code>string</code>, optional): The SNI to use for the TLS handshake with the backend.</li> <li><code>alpn</code> (<code>[]string</code>, optional): A list of ALPN protocols to advertise to the backend.</li> </ul> <p>Example:</p> <pre><code>handler:\n  name: \"my-backend\"\n  type: \"passthrough\"\n  parameter:\n    backend: \"127.0.0.1:8443\"\n    tls:\n      enabled: true\n      insecure_skip_verify: true\n      sni: \"internal.backend\"\n      alpn:\n        - \"h2\"\n</code></pre>"},{"location":"handlers/reverse_proxy/","title":"Reverse Proxy Handler","text":"<p>The <code>reverse_proxy</code> handler acts as an HTTP reverse proxy, forwarding web traffic from the client to a specified backend server. It supports HTTP and WebSocket protocols and includes an optional basic authentication feature.</p>"},{"location":"handlers/reverse_proxy/#configuration","title":"Configuration","text":"<ul> <li><code>backend</code> (<code>string</code>, required): The URL of the backend web server (e.g., <code>http://127.0.0.1:8000</code> or <code>https://backend.example.com</code>). The handler automatically determines whether to use TLS based on the URL's scheme.</li> <li><code>username</code> (<code>string</code>, optional): If provided, TCPMux will require clients to present this username for basic authentication.</li> <li><code>password</code> (<code>string</code>, optional): The password to be used with the username for basic authentication.</li> </ul> <p>Example:</p> <pre><code>handler:\n  name: \"my-web-server\"\n  type: \"reverse_proxy\"\n  parameter:\n    backend: \"https://127.0.0.1:8443\"\n    username: \"admin\"\n    password: \"secure-password\"\n</code></pre>"},{"location":"handlers/socks5/","title":"SOCKS5 Handler","text":"<p>The <code>socks5</code> handler acts as a SOCKS5 proxy server, enabling a client to establish a TCP connection to a destination through the handler. It supports standard SOCKS5 commands and optional username/password authentication for enhanced security.</p> <p>The SOCKS5 Matcher and SOCKS5 Handler are designed to be used together.</p>"},{"location":"handlers/socks5/#configuration","title":"Configuration","text":"<ul> <li><code>username</code> (<code>string</code>, optional): If provided, the handler will enforce username/password authentication. The client must supply this username to proceed.</li> <li><code>password</code> (<code>string</code>, optional): The password to be used in conjunction with the username for authentication. If both <code>username</code> and <code>password</code> are empty, authentication is not required.</li> </ul>"},{"location":"handlers/socks5/#example","title":"Example","text":"<p>This configuration sets up a SOCKS5 handler that requires clients to authenticate with the specified username and password.</p> <pre><code>handler:\n  name: \"secure-socks5\"\n  type: \"socks5\"\n  parameter:\n    username: \"myuser\"\n    password: \"securepassword\"\n</code></pre>"},{"location":"handlers/trojan/","title":"Trojan Handler","text":"<p>The <code>trojan</code> handler implements a Trojan proxy server, enabling clients to forward their TCP and UDP traffic through the handler. It requires clients to authenticate with a pre-shared password and handles both connection and association requests.</p> <p>The Trojan Matcher and Trojan Handler are designed to be used together.</p>"},{"location":"handlers/trojan/#configuration","title":"Configuration","text":"<ul> <li><code>passwords</code> (<code>[]string</code>, optional): A list of valid passwords for the Trojan connection. The handler will validate the client's provided password against this list. If this list is empty, authentication is not performed at the handler level, but it is typically enforced by the matcher.</li> </ul>"},{"location":"handlers/trojan/#example","title":"Example","text":"<p>This configuration sets up a Trojan handler that requires clients to authenticate using one of the two specified passwords before it processes their requests.</p> <pre><code>handler:\n  name: \"secure-trojan\"\n  type: \"trojan\"\n  parameter:\n    passwords:\n      - \"password123\"\n      - \"another-strong-password\"\n</code></pre>"},{"location":"handlers/webserver/","title":"WebServer Handler","text":"<p>The <code>webserver</code> handler serves static files from a specified local directory, functioning as a simple, built-in web server. It's ideal for hosting simple websites, documentation, or providing access to files over HTTP. It includes support for basic authentication and configurable directory listing.</p>"},{"location":"handlers/webserver/#configuration","title":"Configuration","text":"<ul> <li><code>dir</code> (<code>string</code>, required): The absolute or relative path to the local directory that will serve as the web server's root (e.g., <code>/var/www/html</code> or <code>./public</code>).</li> <li><code>username</code> (<code>string</code>, optional): If provided, the handler will require clients to present this username for basic authentication.</li> <li><code>password</code> (<code>string</code>, optional): The password to be used with the username for basic authentication.</li> <li><code>index</code> (<code>bool</code>, optional, default: <code>false</code>): Controls whether to allow directory listings for directories that don't contain an <code>index.html</code> file.<ul> <li>If <code>false</code> (or omitted), accessing such a directory will result in a <code>403 Forbidden</code> error.</li> <li>If <code>true</code>, the contents of the directory will be displayed.</li> </ul> </li> </ul> <p>Example:</p> <pre><code>handler:\n  name: \"my-static-site\"\n  type: \"webserver\"\n  parameter:\n    dir: \"/var/www/my-site\"\n    username: \"viewer\"\n    password: \"simple-password\"\n    index: false\n</code></pre>"},{"location":"matchers/","title":"Matchers","text":"<p>Matchers are the core of TCPMux's routing logic. They analyze incoming connection data to determine which rule to apply.</p> <p>Each matcher is configured with a <code>parameter</code> field in the rule definition.</p> <p>The following matchers are available:</p> <ul> <li>Default</li> <li>Regex</li> <li>Substring</li> <li>TLS</li> <li>HTTP 1.1</li> <li>SSH</li> <li>SOCKS5</li> <li>Trojan</li> <li>IP CIDR</li> <li>Port</li> <li>Timeout</li> <li>Logic (AND/OR)</li> </ul>"},{"location":"matchers/default/","title":"Default Matcher","text":"<p>The <code>default</code> matcher is a simple catch-all matcher that always returns <code>true</code>. It is useful for creating a default rule that handles any traffic not matched by preceding rules.</p>"},{"location":"matchers/default/#configuration","title":"Configuration","text":"<p>The <code>default</code> matcher has no parameters.</p> <p>Example:</p> <pre><code>rules:\n  - name: \"default-catch-all\"\n    type: \"default\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/http/","title":"HTTP 1.1 Matcher","text":"<p>The <code>http</code> matcher inspects the initial bytes of a connection to parse and match against an HTTP request's components.</p>"},{"location":"matchers/http/#configuration","title":"Configuration","text":"<ul> <li><code>methods</code> (<code>[]string</code>, optional): A list of HTTP methods (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>). The comparison is case-insensitive. The matcher returns <code>true</code> if any method in the list matches the request's method.</li> <li><code>url_schemes</code> (<code>[]string</code>, optional): A list of URL schemes (e.g., <code>http</code>, <code>https</code>) to match against the request's URL. Supports <code>*</code> as a wildcard. The comparison is case-insensitive. The matcher returns <code>true</code> if any scheme in the list matches.</li> <li><code>url_hosts</code> (<code>[]string</code>, optional): A list of hosts from the URL (e.g., <code>www.example.com:8080</code>) to match. Supports <code>*</code> as a wildcard. The comparison is case-insensitive. The matcher returns <code>true</code> if any host in the list matches.</li> <li><code>url_paths</code> (<code>[]string</code>, optional, not recommended): A list of URL paths to match. Supports <code>*</code> as a wildcard. The matcher returns <code>true</code> if any path in the list matches the request's path.</li> <li><code>hosts</code> (<code>[]string</code>, optional): A list of <code>Host</code> headers to match. This field corresponds directly to the <code>Host</code> header in the HTTP request. Supports <code>*</code> as a wildcard. The matcher returns <code>true</code> if any host in the list matches the request's <code>Host</code> header.</li> </ul> <p>Host vs. URL Host</p> <p>The <code>hosts</code> parameter matches the HTTP <code>Host</code> header, which is crucial for virtual hosting. The <code>url_hosts</code> parameter, on the other hand, matches the host component of the URL itself.</p> <p>Warning</p> <p>Most web browsers and HTTP clients keep a single TCP connection open for a particular host to handle multiple requests, a process known as connection reuse.</p> <p>This is crucial to understand for the http matcher. Since TCPMux makes its routing decision based on the first request sent over a new connection, subsequent requests on that same reused connection will not be re-evaluated. Instead, they'll be sent to the same backend that the first request was routed to.</p> <p>For this reason, using <code>url_paths</code>, <code>methods</code>, or <code>url_schemes</code> as the primary matching criterion might not work as expected if your client reuses connections. We highly recommend using the <code>hosts</code> or <code>url_hosts</code> parameters as the main rule for routing. If you need more granular routing based on paths or methods, consider using an application-level HTTP reverse proxy like Nginx or Caddy.</p>"},{"location":"matchers/http/#example","title":"Example","text":"<p>This rule matches <code>GET</code> or <code>POST</code> requests sent over <code>https</code> to any path on either <code>api.example.com</code> or <code>dev.api.example.com</code> hosts and directs them to a backend service.</p> <pre><code>rules:\n  - name: \"http-api-rule\"\n    type: \"http\"\n    parameter:\n      methods:\n        - \"GET\"\n        - \"POST\"\n      url_schemes:\n        - \"https\"\n      hosts:\n        - \"api.example.com\"\n        - \"dev.api.example.com\"\n      url_paths:\n        - \"/v1/users/*\"\n        - \"/v2/products/*\"\n    handler:\n      name: \"http-backend\"\n      type: \"passthrough\"\n      parameter:\n        backend: \"127.0.0.1:8080\"\n</code></pre>"},{"location":"matchers/ip/","title":"IP Matcher","text":"<p>The <code>ip</code> matcher filters incoming connections based on their source IP address. It can act as either an allowlist (whitelist) or denylist (blacklist) using a list of CIDR blocks.</p>"},{"location":"matchers/ip/#configuration","title":"Configuration","text":"<ul> <li><code>CIDRs</code> (<code>string[]</code>, required): A list of IPv4 or IPv6 CIDR blocks to match against.</li> <li><code>mode</code> (<code>string</code>, required): Specifies whether the <code>CIDRs</code> list is an <code>allow</code> (whitelist) or <code>deny</code> (blacklist).</li> </ul>"},{"location":"matchers/ip/#examples","title":"Examples","text":""},{"location":"matchers/ip/#allowlist-example","title":"Allowlist Example","text":"<p>This rule only allows connections originating from the <code>192.168.1.0/24</code> subnet. Connections from any other IP will not be matched by this rule.</p> <pre><code>rules:\n  - name: \"internal-traffic-only\"\n    type: \"ip\"\n    parameter:\n      CIDRs:\n        - \"192.168.1.0/24\"\n      mode: \"allow\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/ip/#denylist-example","title":"Denylist Example","text":"<p>This rule blocks all connections from the <code>10.0.0.0/8</code> private network. Any IP within that range will be matched, allowing you to handle them with a specific \"block\" handler.</p> <pre><code>rules:\n  - name: \"block-ten-net\"\n    type: \"ip\"\n    parameter:\n      CIDRs:\n        - \"10.0.0.0/8\"\n      mode: \"deny\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/logic/","title":"Logic Matchers: <code>and</code> and <code>or</code>","text":"<p>These matchers combine multiple rules to create complex matching logic. They are useful for creating nuanced routing policies based on multiple conditions, such as matching a specific IP from a certain host.</p>"},{"location":"matchers/logic/#and-matcher","title":"<code>and</code> Matcher","text":"<p>The <code>and</code> matcher requires all of its sub-matchers to return <code>true</code> for a successful match. If any single sub-matcher fails, the entire rule fails.</p>"},{"location":"matchers/logic/#configuration","title":"Configuration","text":"<ul> <li><code>matchers</code> (<code>object[]</code>, required): A list of objects, each containing a <code>type</code> and <code>parameter</code> field that defines a sub-matcher.</li> </ul>"},{"location":"matchers/logic/#example","title":"Example","text":"<p>This rule matches a connection only if it originates from the <code>192.168.1.0/24</code> subnet and contains the substring \"Hello\" at the beginning of the data stream.</p> <pre><code>rules:\n  - name: \"internal-and-specific-data\"\n    type: \"and\"\n    parameter:\n      matchers:\n        - type: \"ip\"\n          parameter:\n            CIDRs:\n              - \"192.168.1.0/24\"\n            mode: \"allow\"\n        - type: \"substring\"\n          parameter:\n            offset: 0\n            value: \"Hello\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/logic/#or-matcher","title":"<code>or</code> Matcher","text":"<p>The <code>or</code> matcher succeeds if any of its sub-matchers return <code>true</code>. It will short-circuit, meaning it stops checking as soon as it finds a successful match.</p>"},{"location":"matchers/logic/#configuration_1","title":"Configuration","text":"<ul> <li><code>matchers</code> (<code>object[]</code>, required): A list of objects, each containing a <code>type</code> and <code>parameter</code> field that defines a sub-matcher.</li> </ul>"},{"location":"matchers/logic/#example_1","title":"Example","text":"<p>This rule matches a connection if the client's SNI is <code>example.com</code> or if the HTTP host header is <code>api.example.com</code>.</p> <pre><code>rules:\n  - name: \"tls-or-http-host\"\n    type: \"or\"\n    parameter:\n      matchers:\n        - type: \"tls\"\n          parameter:\n            sni: \"example.com\"\n        - type: \"http\"\n          parameter:\n            hosts:\n              - \"api.example.com\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/port/","title":"Port Matcher","text":"<p>The <code>port</code> matcher filters incoming connections based on the destination port they were received on. This is particularly useful when TCPMux is listening on multiple ports and you want to apply different routing rules for each port.</p>"},{"location":"matchers/port/#configuration","title":"Configuration","text":"<ul> <li><code>ports</code> (<code>string[]</code>, required): A list of port numbers (as strings) to match against the destination port of the incoming connection.</li> </ul>"},{"location":"matchers/port/#examples","title":"Examples","text":"<p>This example demonstrates a single rule matching connections on either port 80 or port 443. This can be used to consolidate HTTP and HTTPS traffic from a single listener to a common backend handler.</p> <pre><code>rules:\n  - name: \"web-traffic\"\n    type: \"port\"\n    parameter:\n      ports:\n        - \"80\"\n        - \"443\"\n    handler:\n      name: \"web-handler\"\n      type: \"passthrough\"\n      parameter:\n        backend: \"localhost:8080\"\n</code></pre>"},{"location":"matchers/regex/","title":"Regex Matcher","text":"<p>The <code>regex</code> matcher uses a regular expression to match against the initial bytes of a connection.</p>"},{"location":"matchers/regex/#configuration","title":"Configuration","text":"<ul> <li><code>pattern</code> (<code>string</code>, required): The regular expression pattern to match.</li> </ul> <p>Example:</p> <p>This rule matches <code>SSH</code> traffic by looking for <code>SSH</code> at the beginning of the connection data.</p> <pre><code>rules:\n  - name: \"ssh-rule\"\n    type: \"regex\"\n    parameter:\n      pattern: \"^SSH\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/socks5/","title":"SOCKS5 Matcher","text":"<p>The <code>socks5</code> matcher identifies a connection as a SOCKS5 proxy request based on its initial handshake. It can be configured to check for the presence of specific authentication methods offered by the client.</p> <p>The SOCKS5 Matcher and SOCKS5 Handler are designed to be used together.</p>"},{"location":"matchers/socks5/#configuration","title":"Configuration","text":"<ul> <li><code>allowed_methods</code> (<code>[]string</code>, optional): A list of SOCKS5 authentication methods that the matcher will accept. If this list is empty, the matcher will accept any valid SOCKS5 handshake regardless of the authentication methods offered. Accepted values are <code>no_auth</code> and <code>username_password</code>.</li> </ul>"},{"location":"matchers/socks5/#example","title":"Example","text":""},{"location":"matchers/socks5/#1-matching-any-valid-socks5-request","title":"1. Matching any valid SOCKS5 request","text":"<p>This rule matches any legal SOCKS5 handshake, forwarding the connection to a handler that may or may not enforce authentication.</p> <pre><code>rules:\n  - name: \"any-socks5\"\n    type: \"socks5\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/socks5/#2-requiring-usernamepassword-authentication","title":"2. Requiring username/password authentication","text":"<p>This rule only matches SOCKS5 handshakes where the client offers <code>username_password</code> as an authentication method. This is useful for routing connections to a handler that enforces authentication.</p> <pre><code>rules:\n  - name: \"auth-socks5\"\n    type: \"socks5\"\n    parameter:\n      allowed_methods:\n        - \"username_password\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/ssh/","title":"SSH Matcher","text":"<p>The <code>ssh</code> matcher identifies SSH protocol connections by checking for the presence of the SSH protocol banner at the beginning of the data stream.</p> <p>This matcher requires no parameters.</p> <p>Example:</p> <p>This rule matches any connection that begins with the SSH banner and routes it to an SSH handler.</p> <pre><code>rules:\n  - name: \"ssh-rule\"\n    type: \"ssh\"\n    handler:\n      name: \"ssh-passthrough\"\n      type: \"passthrough\"\n      parameter:\n        backend: \"localhost:22\"\n</code></pre>"},{"location":"matchers/substring/","title":"Substring Matcher","text":"<p>The <code>substring</code> matcher checks if a specific byte sequence exists within the initial data of a connection, starting from a given offset.</p>"},{"location":"matchers/substring/#configuration","title":"Configuration","text":"<ul> <li><code>offset</code> (<code>int</code>, required): The offset in bytes from the start of the data to begin the search.</li> <li><code>value</code> (<code>string</code>, required): The substring to search for.</li> </ul> <p>Example:</p> <p>This rule matches HTTP traffic by checking for \"GET\" near the beginning of the stream.</p> <pre><code>rules:\n  - name: \"http-rule\"\n    type: \"substring\"\n    parameter:\n      offset: 0\n      value: \"GET\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/timeout/","title":"Timeout Matcher","text":"<p>The <code>timeout</code> matcher is unique as it doesn't match based on data. It is triggered if no other rule has matched a connection within a specified timeout period.</p> <p>Note</p> <p>You can only have one <code>timeout</code> rule.</p>"},{"location":"matchers/timeout/#configuration","title":"Configuration","text":"<ul> <li><code>timeout</code> (<code>int</code>, required): The timeout duration in seconds.</li> </ul> <p>Example:</p> <pre><code>rules:\n  - name: \"idle-timeout-rule\"\n    type: \"timeout\"\n    parameter:\n      timeout: 30\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/tls/","title":"TLS Matcher","text":"<p>The <code>tls</code> matcher matches against the Server Name Indication (SNI) and Application-Layer Protocol Negotiation (ALPN) values presented during the TLS handshake.</p> <p>Note</p> <p>This matcher requires <code>tls.enabled: true</code> in your main configuration.</p>"},{"location":"matchers/tls/#configuration","title":"Configuration","text":"<ul> <li><code>sni</code> (<code>string</code>, optional): The SNI to match. If omitted, any SNI will match.</li> <li><code>alpn</code> (<code>[]string</code>, optional): A list of ALPN protocols to match. If omitted, any ALPN will match.</li> </ul> <p>Example:</p> <pre><code>rules:\n  - name: \"example-com-tls\"\n    type: \"tls\"\n    tls_required: true\n    parameter:\n      sni: \"example.com\"\n      alpn:\n        - \"h2\"\n        - \"http/1.1\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/trojan/","title":"Trojan Matcher","text":"<p>The <code>trojan</code> matcher identifies a connection as a Trojan proxy request based on its initial handshake. It validates the client's provided password. The matcher requires the connection to be a TLS connection.</p> <p>The Trojan Matcher and Trojan Handler are designed to be used together.</p>"},{"location":"matchers/trojan/#configuration","title":"Configuration","text":"<ul> <li><code>passwords</code> (<code>[]string</code>, optional): A list of valid passwords for the Trojan connection. The matcher will check if the client's password (hashed using SHA224) matches any of the passwords in this list. If the list is empty, the matcher will only check for the correct Trojan protocol format without enforcing a specific password.</li> </ul>"},{"location":"matchers/trojan/#example","title":"Example","text":""},{"location":"matchers/trojan/#1-matching-any-valid-trojan-request-without-a-specific-password","title":"1. Matching any valid Trojan request without a specific password","text":"<p>This rule matches any legal Trojan handshake, as long as it follows the correct protocol format, and routes the connection to a handler. This can be useful for setups that do not require password validation at the matcher level.</p> <pre><code>rules:\n  - name: \"any-trojan\"\n    type: \"trojan\"\n    handler:\n      # ...\n</code></pre>"},{"location":"matchers/trojan/#2-requiring-a-specific-password","title":"2. Requiring a specific password","text":"<p>This rule only matches Trojan handshakes where the client's provided password (hashed using SHA224) is <code>p@ssw0rd</code>. This is useful for routing connections that require specific authentication.</p> <pre><code>rules:\n  - name: \"auth-trojan\"\n    type: \"trojan\"\n    parameter:\n      passwords:\n        - \"p@ssw0rd\"\n    handler:\n      # ...\n</code></pre>"}]}